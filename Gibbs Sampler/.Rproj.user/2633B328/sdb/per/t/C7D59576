{
    "collab_server" : "",
    "contents" : "library(tidyverse) \nlibrary(MCMCpack)  \nlibrary(LCA) \n\nestadisticos_iniciales <- function(datos){\n  \n  ## esta función regresa una base con la media y varianza para cada\n  ## variable de la base de datos (se toman solo las variables numéricas)\n  \n  nums <- sapply(datos, is.numeric)\n  \n  datos[ , nums]\n  \n  res <- datos[,nums] %>%\n    gather(variable, value) %>%\n    group_by(variable) %>% \n    summarise(media = mean(value),\n              varianza = var(value)) %>%\n    ungroup()\n  return(res)\n  \n}\n## esta funci?n calcula las distribuciones previas, toma como valor por default que sean dos componentes\n##en la funci?n se pueden tomar 1 o mas variables, en el ejemplo solo ocupo 1\ndist_inciales <- function(datos, nom.var = names(datos), componente = 2){\n  \n  \n  est.init <- estadisticos_iniciales(datos) %>%\n    data.frame()\n  \n  k <- componente\n  \n  ## hiperparámetros iniciales que en este caso toman valores de 1 y pi= 1 / #de componentes\n  nj <- rep(1, k)\n  vj <- rep(1, k)\n  sj <- rep(1, k)\n  pi <- rep(1/k, k)\n  \n  ## calcular gamma inversa (cuando se tiene una variable)\n  aux.sigma0 <- data.frame(v = vj,\n                       s = sj) %>%\n    rowwise() %>% \n    mutate(sim = rinvgamma(1, v/2, s/2)) %>%\n    data.frame\n  \n  sigma0 <- aux.sigma0$sim\n  \n  ## calcular normal (cuando se tiene una variable)\n  aux.mu0 <- data.frame(x_barra = rep(est.init[which(est.init$variable == nom.var),2], k),\n                        sigma = sigma0,\n                        n = nj) %>%\n    rowwise() %>%\n    mutate(sim = rnorm(1, x_barra, sigma/n)) %>%\n    data.frame()\n  \n  mu0 <- aux.mu0$sim\n  \n  ## parámetros de las distribuciones inciales\n  param.init <- data.frame(componente = 1:k,\n                           mu_inicial = mu0,\n                           sigma_inicial = sigma0,\n                           pi = pi,\n                           nj = nj,\n                           vj = vj,\n                           sj = sj)\n  \n  return(param.init)\n  \n  \n}\n\nsimulaciones <- function(datos, nom.var = names(datos), componente = 2,\n                         folio = NULL, iteraciones = 1000){\n  \n \n  k <- componente\n  param <- dist_inciales(datos, nom.var, k) ##devuelve los par?metros iniciales\n  sims <- NULL\n  sims_total <- NULL\n  col <- as.numeric(which(names(datos) %in% nom.var))\n  est <- estadisticos_iniciales(datos)\n  mu0 <- as.numeric(est[which(est$variable == nom.var), \"media\"]) #la media obtenida de los datos\n  \n  n <- dim(datos)[1]\n  for(j in 1:iteraciones){\n    \n    ## primer for sirve para actualizar parámetros (mu y sigma) que se calculan con las distribuciones posteriores \n    print(j) ## imprime el n?mero de iteraci?n que ha transcurrido\n    \n    for( i in 1:n){\n      \n     ## se calcula la variable latente para cada una de las Xi's\n      aux <- param %>%\n        mutate(delta = pi*dnorm(datos[i, nom.var],mu_inicial,sqrt(sigma_inicial)),\n               ### en las pruebas por alguna raz?n la delta que se define arriba se vuelve cero, as?\n               ###que por el momento en caso de que eso ocurra le asigno .5 al par?metro p de la bernoulli\n               p_bern = ifelse(sum(delta) != 0, delta/sum(delta), 0.5)) %>%\n               # p_bern = delta/sum(delta)) %>% \n        rowwise() %>%\n        mutate(sim_bern = rbernoulli(1, p_bern)*1,\n               id = datos[i, folio],\n               sim_interna = i,\n               sim = j) %>%\n        data.frame()\n      \n      sims <- rbind(aux, sims)\n    }\n    \n    id_bern <- sims[which(sims$sim_bern == 1), c(\"id\", \"componente\")]\n    ## se hace un filtrado por componente y se saca el numero de xi´s que tiene cada uno\n    ## y la media de cada uno\n    auxj <- sims %>%\n      filter(sim_bern == 1) %>%\n      mutate(n_tot = n()) %>% \n      group_by(componente) %>%\n      summarise(prop = n()) %>%\n      ungroup()\n\n    nom.media <- \"media\"\n    aux.media <- datos %>%\n      left_join(id_bern %>%\n                  setNames(c(folio, \"componente\")), by = folio) %>%\n      filter(!is.na(componente)) %>% \n      dplyr::select(componente,contains(nom.var)) %>% \n      group_by(componente) %>%\n      mutate_(media = paste( \"mean(\" ,  as.name(nom.var)  ,\")\"  ),\n              suma = paste( \"sum(\" ,  as.name(nom.var)  ,\")\"  ),\n              diff = paste(\"(\", as.name(nom.var)  ,\"-\",  as.name(nom.media), \")^2\"  )) %>%\n      summarise(med_tot = mean(media),\n                suma_tot = mean(suma),\n                diff_cuad = sum(diff)^2) ##esta es la suma por componente de (diferencia de xi-media del componente) ^2\n    \n    sigma.sim <- auxj %>% ##se calcula la posterior de sigma\n      left_join(aux.media, by = \"componente\") %>%\n      left_join(param, by = \"componente\") %>%\n      rowwise() %>%\n      mutate(sigma_sim = rinvgamma(1, (vj + prop)/2,\n                                   0.5*( sj^2 + diff_cuad + (nj*prop*(med_tot - mu0)^2)/(nj + prop)))) %>%\n      data.frame\n    \n    mu.sim <- sigma.sim %>%##se calcula la posterior de mu\n      rowwise() %>% \n      mutate(mu_sim = rnorm(1, (nj*mu0 + prop*med_tot)/(nj + prop),\n                            sigma_sim/(nj + prop))) %>%\n      data.frame()\n    \n    pi.sim <- as.numeric(rdirichlet(1, mu.sim$prop/sum(mu.sim$prop)))##se calcula la nueva pi \n    \n    param <- data.frame(componente = 1:k, ##se actualizan los valores de los parametros\n                        mu_inicial = mu.sim$mu_sim,\n                        sigma_inicial = mu.sim$sigma_sim,\n                        pi = pi.sim,\n                        nj = rep(1, k),\n                        vj = rep(1, k),\n                        sj = rep(1, k))\n  \n  }\n  return(sims)\n\n}\n",
    "created" : 1479859937862.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2887840665",
    "id" : "C7D59576",
    "lastKnownWriteTime" : 1480038214,
    "last_content_update" : 1480038214161,
    "path" : "~/GitHub/Tesis1/Gibbs Sampler/funciones.R",
    "project_path" : "funciones.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}