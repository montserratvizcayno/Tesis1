{
    "collab_server" : "",
    "contents" : "library(tidyverse) ## paquetería de Hadely\nlibrary(MCMCpack)  ## inversa gamma\nlibrary(LCA) ## dirichlet\n\nestadisticos_iniciales <- function(datos){\n  \n  ## esta función regresa una base con la media y varianza para cada\n  ## variable de la base de datos (se toman solo las variables numéricas)\n  \n  nums <- sapply(datos, is.numeric)\n  \n  datos[ , nums]\n  \n  res <- datos[,nums] %>%\n    gather(variable, value) %>%\n    group_by(variable) %>% \n    summarise(media = mean(value),\n              varianza = var(value)) %>%\n    ungroup()\n  return(res)\n  \n}\n\ndist_inciales <- function(datos, nom.var = names(datos), componente = 2){\n  \n  ## se calculan media y varianza para las previas\n  est.init <- estadisticos_iniciales(datos) %>%\n    data.frame()\n  \n  k <- componente\n  \n  ## hiperparámetros iniciales (en este caso para simplificar los calculos \n  ##se tomaron nj, sj y vj como 1 y pi como 1/ k)\n  nj <- rep(1, k)\n  vj <- rep(1, k)\n  sj <- rep(1, k)\n  pi <- rep(1/k, k)\n  \n  ## calcular gamma inversa (cuando se tiene una variable)\n  aux.sigma0 <- data.frame(v = vj,\n                       s = sj) %>%\n    rowwise() %>% \n    mutate(sim = rinvgamma(1, v/2, s/2)) %>%\n    data.frame\n  \n  sigma0 <- aux.sigma0$sim\n  \n  ## calcular normal (cuando se tiene una variable)\n  aux.mu0 <- data.frame(x_barra = rep(est.init[which(est.init$variable == nom.var),2], k),\n                        sigma = sigma0,\n                        n = nj) %>%\n    rowwise() %>%\n    mutate(sim = rnorm(1, x_barra, sigma/n)) %>%\n    data.frame()\n  \n  mu0 <- aux.mu0$sim\n  \n  ## parámetros de las distribuciones inciales\n  param.init <- data.frame(componente = 1:k,\n                           mu_inicial = mu0,\n                           sigma_inicial = sigma0,\n                           pi = pi,\n                           nj = nj,\n                           vj = vj,\n                           sj = sj)\n  \n  return(param.init)\n  \n  \n}\n\nsimulaciones <- function(datos, nom.var = names(datos), componente = 2,\n                         folio = NULL, iteraciones = 1000){\n  \n  ## iniciar parámetros\n  k <- componente\n  param <- dist_inciales(datos, nom.var, k)\n  sims <- NULL\n  sims_total <- NULL\n  col <- as.numeric(which(names(datos) %in% nom.var))\n  est <- estadisticos_iniciales(datos)\n  mu0 <- as.numeric(est[which(est$variable == nom.var), \"media\"])\n  \n  n <- dim(datos)[1]\n  for(j in 1:iteraciones){\n    \n    ## primer for sirve para actualizar parámetros (mu y sigma)  \n    print(j)\n    \n    for( i in 1:n){\n      \n      ## evaluación de cada unas de las x_i\n      aux <- param %>%\n        mutate(delta = pi*dnorm(datos[i, nom.var],mu_inicial,sqrt(sigma_inicial)),\n               ### mon, aquí hay pedos cuando las deltas son ceros entonces le puse que si la\n               ### suma de las deltas es cero te ponga un 0.5 :/ pregúntale al prof que pedo\n               p_bern = ifelse(sum(delta) != 0, delta/sum(delta), 0.5)) %>%\n               # p_bern = delta/sum(delta)) %>% \n        rowwise() %>%\n        mutate(sim_bern = rbernoulli(1, p_bern)*1,\n               id = datos[i, folio],\n               sim_interna = i,\n               sim = j) %>%\n        data.frame()\n      \n      sims <- rbind(aux, sims)\n    }\n    \n    id_bern <- sims[which(sims$sim_bern == 1), c(\"id\", \"componente\")]\n    \n    auxj <- sims %>%\n      filter(sim_bern == 1) %>%\n      mutate(n_tot = n()) %>% \n      group_by(componente) %>%\n      summarise(prop = n()) %>%\n      ungroup()\n\n    nom.media <- \"media\"\n    aux.media <- datos %>%\n      left_join(id_bern %>%\n                  setNames(c(folio, \"componente\")), by = folio) %>%\n      filter(!is.na(componente)) %>% \n      dplyr::select(componente,contains(nom.var)) %>% \n      group_by(componente) %>%\n      mutate_(media = paste( \"mean(\" ,  as.name(nom.var)  ,\")\"  ),\n              suma = paste( \"sum(\" ,  as.name(nom.var)  ,\")\"  ),\n              diff = paste(\"(\", as.name(nom.var)  ,\"-\",  as.name(nom.media), \")^2\"  )) %>%\n      summarise(med_tot = mean(media),\n                suma_tot = mean(suma),\n                diff_cuad = sum(diff)^2)\n    \n    sigma.sim <- auxj %>%\n      left_join(aux.media, by = \"componente\") %>%\n      left_join(param, by = \"componente\") %>%\n      rowwise() %>%\n      mutate(sigma_sim = rinvgamma(1, (vj + prop)/2,\n                                   0.5*( sj^2 + diff_cuad + (nj*prop*(med_tot - mu0)^2)/(nj + prop)))) %>%\n      data.frame\n    \n    mu.sim <- sigma.sim %>%\n      rowwise() %>% \n      mutate(mu_sim = rnorm(1, (nj*mu0 + prop*med_tot)/(nj + prop),\n                            sigma_sim/(nj + prop))) %>%\n      data.frame()\n    \n    pi.sim <- as.numeric(rdirichlet(1, mu.sim$prop/sum(mu.sim$prop)))\n    \n    param <- data.frame(componente = 1:k,\n                        mu_inicial = mu.sim$mu_sim,\n                        sigma_inicial = mu.sim$sigma_sim,\n                        pi = pi.sim,\n                        nj = rep(1, k),\n                        vj = rep(1, k),\n                        sj = rep(1, k))\n  \n  }\n  return(sims)\n\n}\n",
    "created" : 1479859937862.000,
    "dirty" : true,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2463037891",
    "id" : "C7D59576",
    "lastKnownWriteTime" : 1479859126,
    "last_content_update" : 1479861995089,
    "path" : "~/R/tesis_mon/funciones.R",
    "project_path" : "funciones.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}